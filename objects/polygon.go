package objects

import (
	"fmt"
	"math"

	"github.com/libeks/go-plotter-svg/lines"
	"github.com/libeks/go-plotter-svg/maths"
	"github.com/libeks/go-plotter-svg/primitives"
)

const FLOAT_ACCURACY = 0.0001

type Polygon struct {
	Points []primitives.Point
}

func (p Polygon) String() string {
	return fmt.Sprintf("Polygon (%v)", p.Points)
}

// return the angle generated by visiting all polygon vertices from the perspective of this point
// This can be used to determine whether the point is inside the polygon
//
//	(it is inside if we've traced a full circle, it is outside if we end up with an angle of 0)
//
// But can also be used to determine whether the polygon is specified in clock-wise or counter-clock-wise order
func (p Polygon) pointWindingAngle(pt primitives.Point) float64 {
	totalAngle := 0.0
	for i, p1 := range p.Points {
		j := (i + 1) % len(p.Points)
		p2 := p.Points[j]

		p2Angle := p2.Subtract(pt).Atan()
		p1Angle := p1.Subtract(pt).Atan()
		angle := maths.AngleDifference(p2Angle, p1Angle)
		totalAngle += angle
	}
	return totalAngle
}

// Flip the order of the vertices of a polygon, so that it goes from clockwise to counter-clockwise, or vice-versa
func (p Polygon) Reverse() Polygon {
	points := make([]primitives.Point, len(p.Points))
	for i := range len(p.Points) {
		points[i] = p.Points[maths.Mod(-i, len(p.Points))]
	}
	return Polygon{Points: points}
}

// Given a face index, return the index of the next face, wrapping around
func (p Polygon) NextFaceIndex(i int) int {
	return maths.Mod(i+1, len(p.Points))
}

// Given a face index, return the index of the next face, wrapping around
func (p Polygon) PreviousFaceIndex(i int) int {
	return maths.Mod(i-1, len(p.Points))
}

// Inside returns true if the point is inside the polygon, false otherwise
func (p Polygon) Inside(pt primitives.Point) bool {
	totalAngle := p.pointWindingAngle(pt)
	// check if polygon is in clockwise order
	if math.Abs(totalAngle-math.Pi) < FLOAT_ACCURACY {
		return true
	}
	// check if polygon is in counter-clockwise order
	if math.Abs(totalAngle+math.Pi) < FLOAT_ACCURACY {
		return true
	}
	// if the angle is zero, the point is outside of the polygon
	if math.Abs(totalAngle) < FLOAT_ACCURACY {
		return false
	}
	panic(fmt.Errorf("not sure what to do with winding angle %.3f", totalAngle))
}

func (p Polygon) Translate(v primitives.Vector) Polygon {
	points := make([]primitives.Point, len(p.Points))
	for i, pt := range p.Points {
		points[i] = pt.Add(v)
	}
	return Polygon{
		Points: points,
	}
}

func (p Polygon) EdgeLines() []lines.LineSegment {
	segments := []lines.LineSegment{}
	for i, p1 := range p.Points {
		j := (i + 1) % len(p.Points)
		p2 := p.Points[j]
		segments = append(segments, lines.LineSegment{P1: p1, P2: p2})
	}
	return segments
}

func (p Polygon) IntersectTs(line lines.Line) []float64 {
	ts := []float64{}
	for _, segment := range p.EdgeLines() {
		if t := line.IntersectLineSegmentT(segment); t != nil {
			ts = append(ts, *t)
		}
	}
	return deduplicate(ts)
}

// Midpoint returns the average of all vertices of a polygon. This is helpful sometimes, but not other times.
// It is only guaranteed to be inside of the polygon if it is convex.
func (p Polygon) Midpoint() primitives.Point {
	var midpoint primitives.Point
	for _, pt := range p.Points {
		midpoint.X += pt.X / float64(len(p.Points))
		midpoint.Y += pt.Y / float64(len(p.Points))
	}
	return midpoint
}

func (p Polygon) BBox() primitives.BBox {
	return primitives.BBoxAroundPoints(p.Points...)
}

// Find the largest square inside the rectangle whose center is the midpoint of all corners
// this is not guaranteed to be the biggets ortogonal square in this polygon
func (p Polygon) findCenterBBox() primitives.BBox {
	midpoint := p.Midpoint()
	outsideBox := p.BBox()

	size := max(outsideBox.Width(), outsideBox.Height())
	var bbox primitives.BBox
	// TODO: Do a binary search with a threshold instead
	for {
		bbox = primitives.BBox{
			UpperLeft:  midpoint.Add(primitives.Vector{X: -math.Sqrt(2), Y: -math.Sqrt(2)}.Mult(size / 2)),
			LowerRight: midpoint.Add(primitives.Vector{X: math.Sqrt(2), Y: math.Sqrt(2)}.Mult(size / 2)),
		}
		if p.isBBoxInside(bbox) {
			return bbox
		}

		size = size * 0.95
		if size < 1.0 {
			// panic("Bounding box too small")
			return primitives.BBox{}
		}
	}
}

// Find the largest axis-aligned square that can be inscribed in the polygon
func (p Polygon) LargestContainedSquareBBox() primitives.BBox {
	// Current algo starts with the midpoint of all points and iteratively shrinks the square until it fits,
	// but this is not nearly optimal. Other ideas:
	//
	// * find a square that fits, then try to wiggle it around and increase the side length
	// * start by finding the midpoint of all angles (how does that work for non-triangles)
	// * for each vertical and horizontal, compute the width/height of the polygon, then use the intersection
	//   points as candidates, this also limits how far to adjust for
	// Consider https://cgm.cs.mcgill.ca/~athens/cs507/Projects/2003/DanielSud/
	bbox := p.findCenterBBox()
	oldSize := 0.0
	for bbox.Width() > oldSize {
		oldSize = bbox.Width()
		for i := range 8 {
			candidate := bbox.Translate(primitives.UnitRight.RotateCCW(math.Pi / 4.0 * float64(i)).Mult(bbox.Width() * 0.01))
			candidate = candidate.Scale(1.005)
			if math.Abs(1.0-candidate.Width()/candidate.Height()) > FLOAT_ACCURACY {
				fmt.Printf("width %f, height %f\n", candidate.Width(), candidate.Height())
				panic("polygon is not a square")
			}
			if p.isBBoxInside(candidate) {
				bbox = candidate
				break
			}
		}
	}
	return bbox
}

func deduplicate(ts []float64) []float64 {
	tMap := map[float64]struct{}{}
	for _, t := range ts {
		tMap[t] = struct{}{}
	}
	retList := []float64{}
	for key := range tMap {
		retList = append(retList, key)
	}
	return retList
}

// return a slice of parallel line segments that completely fill the polygon, at 'spacing' apart
func (p Polygon) LineFill(angle, spacing float64) []lines.LineLike {
	// start with a line perpendicular to the angle
	// find the line-t value of each polygon vertex projected onto this line
	// sort these t-values
	// starting at the smallest t-value to the largest, produce perpendicular lines with the correct spacing apart
	// for each line, intersect with polygon to find the line segment that is inside the polygon
	v := primitives.UnitRight.RotateCCW(-angle)
	vPerp := v.Perp() // unit vector perpendicular to the angle
	tValues := make([]float64, len(p.Points))

	for i, point := range p.Points {
		vp := point.Subtract(primitives.Origin)
		tValues[i] = vp.Dot(vPerp) / (vPerp.Dot(vPerp))
	}
	minT := tValues[0]
	maxT := tValues[0]
	for _, t := range tValues {
		if t < minT {
			minT = t
		}
		if t > maxT {
			maxT = t
		}
	}
	perpLine := lines.Line{
		P: primitives.Origin,
		V: vPerp,
	}
	lineLikes := []lines.LineLike{}
	reverse := false
	for i := range int((maxT-minT)/spacing) + 1 {
		lineT := minT + float64(i)*spacing
		line := lines.Line{
			P: perpLine.At(lineT),
			V: v,
		}
		ts := p.IntersectTs(line)
		if len(ts) == 2 {
			var segment lines.LineSegment
			if reverse {
				segment = lines.LineSegment{
					P1: line.At(ts[1]),
					P2: line.At(ts[0]),
				}
			} else {
				segment = lines.LineSegment{
					P1: line.At(ts[0]),
					P2: line.At(ts[1]),
				}
			}
			lineLikes = append(lineLikes, segment)

		} else if len(ts) > 2 {
			fmt.Printf("ts %v\n", ts)
			panic("Unexpected t-values for line and polygon intersection")
		}
		reverse = !reverse
	}
	return lineLikes
}

// EdgeSegments return the line segments that constitute the polygon
func (p Polygon) EdgeSegments() []lines.LineSegment {
	edges := make([]lines.LineSegment, len(p.Points))
	for i := range len(p.Points) {
		pointA := p.Points[maths.Mod(i-1, len(p.Points))] // ensure that it wraps around beautifully
		pointB := p.Points[i]
		edges[i] = lines.LineSegment{P1: pointA, P2: pointB}
	}
	return edges
}

// Grow increases the polygon outwards (or inwards, if d is negative), by moving every
// edge line outwards perpendicular to itself by the distance d.
// If the resulting polygon is too small, this will return a polygon with no edges
func (p Polygon) Grow(d float64) Polygon {
	// for every point,
	//   take the edges that the point falls on,
	//   take their lines,
	//   extend each line perpendicularly outward by d
	//   find the new intersection point of the extended lines

	// make sure that a positive 'd' parameter always grows the polygon outwards
	if !p.isClockwise() {
		d = -d
	}
	edges := make([]lines.Line, len(p.Points))
	for i := range len(p.Points) {
		pointA := p.Points[maths.Mod(i-1, len(p.Points))] // ensure that it wraps around beautifully
		pointB := p.Points[i]

		edges[i] = lines.Line{P: pointA, V: pointB.Subtract(pointA).Unit()}
	}
	for i, edge := range edges {
		edges[i] = lines.Line{P: edge.P.Add(edge.V.Perp().Unit().Mult(d)), V: edge.V}
	}
	points := []primitives.Point{}
	for i := range edges {
		edgeA := edges[maths.Mod(i-1, len(edges))] // ensure that it wraps around beautifully
		edgeB := edges[i]
		intersection := edgeA.Intersect(edgeB)
		if intersection == nil {
			return Polygon{}
		}
		points = append(points, *intersection)
	}

	return Polygon{Points: points}
}

// should return circle t-values
func (p Polygon) IntersectCircleTs(circle Circle) []float64 {
	ts := []float64{}
	for _, segment := range p.EdgeLines() {
		t := circle.IntersectLineSegmentT(segment)
		ts = append(ts, t...)
	}
	return ts
}

// returns true if the vertices of the polygon are specified in a clockwise order, otherwise false
func (p Polygon) isClockwise() bool {
	midpoint := p.Midpoint()
	if !p.Inside(midpoint) {
		panic("The midpoint is not inside the polygon, isClockwise won't work here")
	}
	totalAngle := p.pointWindingAngle(midpoint)
	return math.Abs(totalAngle+math.Pi) < FLOAT_ACCURACY
}

func (p Polygon) isBBoxInside(bbox primitives.BBox) bool {
	pts := bbox.Corners()
	for _, pt := range pts {
		if !p.Inside(pt) {
			return false
		}
	}
	return true
}

func PolygonFromBBox(b primitives.BBox) Polygon {
	return Polygon{
		Points: b.Corners(),
	}
}
